---
description: FastAPI best practices and patterns for HackRx
globs: ["main*.py", "services/*.py", "routers/*.py", "api/*.py"]
alwaysApply: false
---

# FastAPI Best Practices

## Application Structure
- Use functional components (plain functions) and Pydantic models
- Use declarative route definitions with clear return type annotations
- Structure: exported router, sub-routes, utilities, static content, types (models, schemas)
- Use def for synchronous operations and async def for asynchronous ones

## Lifecycle Management
- Minimize @app.on_event("startup") and @app.on_event("shutdown")
- Prefer lifespan context managers for managing startup and shutdown events
- Use dependency injection for managing state and shared resources
- Implement proper cleanup in shutdown handlers

## Middleware and Error Handling
- Use middleware for logging, error monitoring, and performance optimization
- Use HTTPException for expected errors and model them as specific HTTP responses
- Use middleware for handling unexpected errors, logging, and error monitoring
- Implement proper error logging and user-friendly error messages
- Use custom error types or error factories for consistent error handling

## Performance Optimization
- Optimize for performance using async functions for I/O-bound tasks
- Implement caching strategies and lazy loading
- Minimize blocking I/O operations; use async for all database and external API calls
- Optimize data serialization and deserialization with Pydantic
- Use lazy loading techniques for large datasets and substantial API responses

## Validation and Models
- Use Pydantic's BaseModel for consistent input/output validation and response schemas
- Prefer Pydantic models over raw dictionaries for input validation
- Use type hints for all function signatures
- Implement proper request/response validation

## Route Design
- Use descriptive route names with clear HTTP methods
- Implement proper HTTP status codes
- Add CORS middleware for web applications
- Use background tasks for long-running operations
- Implement health check endpoints

## Dependency Injection
- Rely on FastAPI's dependency injection system for managing state and shared resources
- Use dependencies for database connections, caching, and external services
- Structure routes and dependencies clearly to optimize readability and maintainability
- Use dependency overrides for testing

## API Design Patterns
- Use the Receive an Object, Return an Object (RORO) pattern
- Favor named exports for routes and utility functions
- Use lowercase with underscores for route paths
- Implement consistent response formats

## Performance Metrics
- Prioritize API performance metrics (response time, latency, throughput)
- Monitor response times and implement caching where appropriate
- Use connection pooling for databases
- Implement rate limiting and resource management

## Testing and Documentation
- Write integration tests for API endpoints
- Use FastAPI's automatic documentation features
- Include request/response examples in docstrings
- Test error scenarios and edge cases

Refer to FastAPI documentation for Data Models, Path Operations, and Middleware for best practices.
