---
description: Python coding standards and best practices for HackRx
globs: ["*.py", "services/*.py", "utils/*.py"]
alwaysApply: true
---

# Python Coding Standards

## Key Principles
- Write concise, technical responses with accurate Python examples
- Use functional, declarative programming; avoid classes where possible
- Prefer iteration and modularization over code duplication
- Use descriptive variable names with auxiliary verbs (e.g., is_active, has_permission)
- Use lowercase with underscores for directories and files (e.g., routers/user_routes.py)
- Favor named exports for routes and utility functions
- Use the Receive an Object, Return an Object (RORO) pattern

## Python Best Practices
- Use Python 3.9+ features and type hints
- Follow PEP 8 style guidelines
- Use async/await for I/O operations
- Implement proper error handling with try/catch blocks
- Add comprehensive docstrings for all functions and classes

## FastAPI-Specific Guidelines
- Use functional components (plain functions) and Pydantic models for input validation and response schemas
- Use declarative route definitions with clear return type annotations
- Use def for synchronous operations and async def for asynchronous ones
- Minimize @app.on_event("startup") and @app.on_event("shutdown"); prefer lifespan context managers
- Use middleware for logging, error monitoring, and performance optimization
- Optimize for performance using async functions for I/O-bound tasks, caching strategies, and lazy loading
- Use HTTPException for expected errors and model them as specific HTTP responses
- Use middleware for handling unexpected errors, logging, and error monitoring
- Use Pydantic's BaseModel for consistent input/output validation and response schemas

## Type Hints
- Use type hints for all function signatures
- Prefer Pydantic models over raw dictionaries for input validation
- Use Union types for optional parameters
- Import types from typing module when needed

## Error Handling and Validation
- Prioritize error handling and edge cases:
  - Handle errors and edge cases at the beginning of functions
  - Use early returns for error conditions to avoid deeply nested if statements
  - Place the happy path last in the function for improved readability
  - Avoid unnecessary else statements; use the if-return pattern instead
  - Use guard clauses to handle preconditions and invalid states early
  - Implement proper error logging and user-friendly error messages
  - Use custom error types or error factories for consistent error handling

## Async Patterns
- Use async def for functions that perform I/O operations
- Use asyncio.gather() for concurrent operations
- Implement proper semaphore limits for resource control
- Handle async context managers properly

## Performance Optimization
- Minimize blocking I/O operations; use asynchronous operations for all database calls and external API requests
- Implement caching for static and frequently accessed data using tools like Redis or in-memory stores
- Optimize data serialization and deserialization with Pydantic
- Use lazy loading techniques for large datasets and substantial API responses

## Key Conventions
1. Rely on FastAPI's dependency injection system for managing state and shared resources
2. Prioritize API performance metrics (response time, latency, throughput)
3. Limit blocking operations in routes:
   - Favor asynchronous and non-blocking flows
   - Use dedicated async functions for database and external API operations
   - Structure routes and dependencies clearly to optimize readability and maintainability

## Documentation
- Add comprehensive docstrings using Google or NumPy style
- Include usage examples in docstrings
- Document complex algorithms and business logic
- Keep README files updated with latest changes

## Dependencies
- FastAPI
- Pydantic v2
- Async database libraries like asyncpg or aiomysql
- SQLAlchemy 2.0 (if using ORM features)

Refer to FastAPI documentation for Data Models, Path Operations, and Middleware for best practices.
